# GIẢI THÍCH CHI TIẾT CÁC PHẦN CÒN LẠI (HATEOAS, QUERY, SECURITY, TEST)

**Tài liệu hỗ trợ thuyết trình bảo vệ đồ án**

Ngoài OOP, dưới đây là giải thích chi tiết cho 5 điểm còn lại của bài kiểm tra.

---

## 1. HATEOAS (1 điểm)

**Khái niệm:** _Hypermedia as the Engine of Application State_.
Đơn giản là: API không chỉ trả về dữ liệu, mà trả về cả **đường dẫn (link)** để client biết làm gì tiếp theo.

**File code:** `src/main/java/com/flower/manager/controller/product/ProductController.java`

**Giải thích code:**
Chúng ta sử dụng `WebMvcLinkBuilder` để tạo link động.

```java
private ProductDTO addLinks(ProductDTO product) {
    // 1. Tạo link "self" (như thẻ <a href="...">) trỏ đến chính nó
    // methodOn...getById(id) giúp lấy URL từ hàm getById mà không cần gõ cứng chuỗi string
    product.add(linkTo(methodOn(ProductController.class).getById(product.getId())).withSelfRel());

    // 2. Tạo link "category" trỏ đến danh mục của nó
    if (product.getCategoryId() != null) {
        product.add(linkTo(methodOn(ProductController.class).getByCategory(product.getCategoryId()))
                .withRel("category"));
    }
    return product;
}
```

**Kết quả khi chạy (JSON):**

```json
{
  "id": 1,
  "name": "Hoa Hồng Đỏ",
  "_links": {
    "self": { "href": "http://localhost:8080/api/products/1" },
    "category": { "href": "http://localhost:8080/api/products/category/1" }
  }
}
```

---

## 2. Truy vấn (Query) (2 điểm)

Bạn cần show file `src/main/java/com/flower/manager/repository/ProductRepository.java`.

### A. Truy vấn cơ bản (Basic)

Spring Data JPA tự động sinh câu lệnh SQL dựa trên tên hàm (Derived Query).

```java
// Tìm sản phẩm theo Slug
Optional<Product> findBySlug(String slug);
// SQL sinh ra: SELECT * FROM products WHERE slug = ?

// Tìm theo trạng thái và sắp xếp ngày tạo giảm dần
List<Product> findByStatusOrderByCreatedAtDesc(Integer status);
// SQL: SELECT * FROM products WHERE status = ? ORDER BY created_at DESC
```

### B. Truy vấn phức tạp (Advanced @Query)

Sử dụng JPQL (Java Persistence Query Language) để xử lý logic khó.

**Ví dụ 1: Tìm kiếm nâng cao (Dynamic Filter)**
Logic: Người dùng có thể tìm theo tên, HOẶC giá, HOẶC danh mục (cái nào null thì bỏ qua).

```java
@Query("SELECT p FROM Product p " +
       "LEFT JOIN FETCH p.category c " + // JOIN để lấy luôn tên danh mục (tránh lỗi N+1)
       "WHERE p.active = true " +
       // Nếu keyword null thì bỏ qua, nếu có thì LIKE
       "AND (:keyword IS NULL OR LOWER(p.name) LIKE LOWER(CONCAT('%', :keyword, '%'))) " +
       "AND (:priceFrom IS NULL OR p.price >= :priceFrom) " +
       "ORDER BY p.price ASC")
List<Product> advancedSearchOrderByPriceAsc(...);
```

**Ví dụ 2: Thống kê Best Selling (Aggregation)**
Logic: Tính tổng số lượng bán ra (`SUM quantity`) từ bảng chi tiết đơn hàng, gom nhóm theo sản phẩm (`GROUP BY product`).

```java
@Query("SELECT oi.product.id FROM OrderItem oi " +
       "JOIN oi.order o " +
       "WHERE o.status = 'COMPLETED' " + // Chỉ tính đơn thành công
       "GROUP BY oi.product.id " +
       "ORDER BY SUM(oi.quantity) DESC") // Sắp xếp ai bán nhiều nhất lên đầu
List<Long> findBestSellingProductIds();
```

---

## 3. Unit Test (1 điểm)

**File code:** `src/test/java/com/flower/manager/service/product/ProductServiceTest.java`

**Giải thích:**
Chúng ta test tầng Service mà **không cần chạy Database thật**. Ta dùng `Mockito` để tạo các đối tượng giả (Mock).

**Kịch bản test mẫu:**

```java
@Test
void create_ShouldReturnProductDTO_WhenSuccessful() {
    // 1. GIVEN (Chuẩn bị): Giả sử Repository luôn lưu thành công
    // Khi gọi categoryRepository.findById(1) -> Hãy trả về đối tượng category mẫu
    when(categoryRepository.findById(1L)).thenReturn(Optional.of(category));
    // Khi gọi productRepository.save(...) -> Hãy trả về product mẫu
    when(productRepository.save(any(Product.class))).thenReturn(product);

    // 2. WHEN (Thực hiện): Gọi hàm create của service
    ProductDTO result = productService.create(createDTO);

    // 3. THEN (Kiểm tra): Kết quả không được null
    assertNotNull(result);
    // Kiểm tra xem repository.save() đã thực sự được gọi 1 lần chưa
    verify(productRepository, times(1)).save(any(Product.class));
}
```

---

## 4. Security (1 điểm)

**Cơ chế:** Stateless Authentication dùng JWT (JSON Web Token).
**File code:** `src/main/java/com/flower/manager/config/SecurityConfig.java`

**Luồng đi:**
Request -> `JwtAuthenticationFilter` -> Gửi tới Controller.

**Cấu hình phân quyền:**

```java
http.authorizeHttpRequests(auth -> auth
    // API Public (Ai cũng xem được): Sản phẩm, Danh mục
    .requestMatchers(HttpMethod.GET, "/api/products/**").permitAll()

    // API Admin (Chỉ Admin mới được vào): Quản lý
    .requestMatchers("/api/admin/**").hasRole("ADMIN")

    // Các API khác: Phải đăng nhập (Authenticated)
    .anyRequest().authenticated()
);
```

**Cách demo:**

1. Mở Postman/Web, vào trang Admin khi chưa đăng nhập -> Lỗi 403 Forbidden.
2. Đăng nhập -> Lấy Token -> Gửi kèm Header `Authorization: Bearer ...` -> Vào được.
