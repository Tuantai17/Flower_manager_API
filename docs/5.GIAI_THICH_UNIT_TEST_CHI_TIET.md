# GIẢI THÍCH CHI TIẾT VỀ UNIT TEST (1 ĐIỂM)

**Tài liệu hỗ trợ thuyết trình phần Kiểm thử đơn vị**

Dự án sử dụng thư viện **Mockito** kết hợp với **JUnit 5** để kiểm thử tầng Service một cách độc lập (Isolated Testing), không phụ thuộc vào Database thật.

**File Code Chính**: `src/test/java/com/flower/manager/service/product/ProductServiceTest.java`

---

## 1. Các Khái Niệm Quan Trọng (Mockito)

Trước khi vào code, cần hiểu các Annotation được sử dụng:

- **`@ExtendWith(MockitoExtension.class)`**: Báo cho JUnit 5 biết lớp test này sẽ sử dụng các tính năng của Mockito.
- **`@Mock` (Giả lập)**: Tạo ra một phiên bản "giả" của các dependency (ví dụ: `ProductRepository`). Nó không chạy code thật, không gọi database thật, mà chỉ trả về kết quả do ta quy định.
- **`@InjectMocks` (Tiêm dependencies)**: Tạo ra đối tượng cần test (`ProductService`) và tự động "tiêm" các Mock ở trên vào nó.
  - Ví dụ: Service cần Repository, thì Mockito sẽ lấy Mock Repository nhét vào Service.

---

## 2. Giải Thích Code Chi Tiết

### A. Kịch bản Test Thành Công (Happy Path)

Test hàm `create` khi mọi thứ hợp lệ.

```java
@Test
void create_ShouldReturnProductDTO_WhenSuccessful() {
    // === PHẦN 1: GIVEN (Chuẩn bị dữ liệu giả) ===

    // Giả sử: Kiểm tra slug, Repository bảo "chưa tồn tại" (false)
    when(productRepository.existsBySlug(createDTO.getSlug())).thenReturn(false);

    // Giả sử: Tìm Category ID=1, Repository trả về object category mẫu
    when(categoryRepository.findById(1L)).thenReturn(Optional.of(category));

    // Giả sử: Khi Mapper convert DTO -> Entity, nó trả về object product mẫu
    when(productMapper.toEntity(createDTO)).thenReturn(product);

    // Giả sử: Khi gọi Save xuống DB, nó trả về object product đã lưu
    when(productRepository.save(any(Product.class))).thenReturn(product);

    // Giả sử: Convert ngược lại Entity -> DTO trả về kết quả mong muốn
    when(productMapper.toDTO(product)).thenReturn(productDTO);

    // === PHẦN 2: WHEN (Thực thi hành động cần test) ===
    ProductDTO result = productService.create(createDTO);

    // === PHẦN 3: THEN (Kiểm tra kết quả) ===

    // Kiểm tra kết quả trả về không được null
    assertNotNull(result);

    // Kiểm tra tên sản phẩm trả về có đúng như mong đợi không
    assertEquals(productDTO.getName(), result.getName());

    // QUAN TRỌNG: Kiểm tra xem hàm save() của Repository đã được gọi đúng 1 lần chưa?
    // (Đảm bảo logic code thực sự đã đi qua dòng lệnh save)
    verify(productRepository, times(1)).save(any(Product.class));
}
```

### B. Kịch bản Test Thất Bại (Exception Path)

Test hàm `create` khi trùng tên (Duplicate Slug) -> Phải ném lỗi.

```java
@Test
void create_ShouldThrowException_WhenSlugExists() {
    // === GIVEN ===
    // Giả sử: Repository bảo "slug này đã có rồi" (true)
    when(productRepository.existsBySlug(createDTO.getSlug())).thenReturn(true);

    // === WHEN & THEN ===
    // Kiểm tra: Khi gọi hàm create(...) thì PHẢI ném ra lỗi IllegalArgumentException
    assertThrows(IllegalArgumentException.class, () -> productService.create(createDTO));

    // Kiểm tra: Đảm bảo rằng hàm save() KHÔNG BAO GIỜ được gọi (vì lỗi từ trước đó)
    verify(productRepository, never()).save(any(Product.class));
}
```

---

## 3. Tổng kết để nói với giáo viên

"Trong phần Unit Test, em sử dụng **Mockito** để mock các Repository. Mục đích là để test riêng biệt logic nghiệp vụ của Service (như validate dữ liệu, luồng if-else) mà không cần khởi động Database phức tạp.
Em đã viết các test case bao phủ cả trường hợp thành công (trả về DTO) và trường hợp lỗi (ném Exception khi trùng lặp)."
