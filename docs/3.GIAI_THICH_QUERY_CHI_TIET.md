# GIẢI THÍCH CHI TIẾT VỀ QUERY (TRUY VẤN DỮ LIỆU) - 2 ĐIỂM

**Tài liệu hỗ trợ thuyết trình phần Cơ sở dữ liệu & Truy vấn**

Dự án sử dụng **Spring Data JPA** để tương tác với cơ sở dữ liệu. Điểm mạnh ở đây là kết hợp giữa sự tiện lợi của **Derived Queries** (Cơ bản) và sức mạnh của **JPQL** (Nâng cao).

**File Code Chính**: `src/main/java/com/flower/manager/repository/ProductRepository.java`

---

## 1. Truy Vấn Cơ Bản (Basic Queries)

**Cơ chế**: "Derived Query Methods" (Phương thức dẫn xuất).
Spring Data JPA tự động phân tích tên hàm và sinh ra câu lệnh SQL tương ứng mà không cần viết một dòng SQL nào.

**Ví dụ trong Code:**

```java
// 1. Tìm sản phẩm theo Slug
Optional<Product> findBySlug(String slug);
// -> Tương đương SQL: SELECT * FROM products WHERE slug = ?

// 2. Tìm danh sách theo Status và sắp xếp ngày tạo giảm dần (Mới nhất lên đầu)
List<Product> findByStatusOrderByCreatedAtDesc(Integer status);
// -> Tương đương SQL: SELECT * FROM products WHERE status = ? ORDER BY created_at DESC

// 3. Kiểm tra tồn tại (Trả về True/False)
boolean existsBySlug(String slug);
// -> Tương đương SQL: SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM products...
```

✅ **Ưu điểm**: Nhanh, gọn, code sạch sẽ, dễ đọc.

---

## 2. Truy Vấn Phức Tạp (Advanced Queries)

**Cơ chế**: Sử dụng Annotation `@Query` với ngôn ngữ **JPQL** (Java Persistence Query Language).
Cho phép thực hiện các nghiệp vụ khó mà cách đặt tên hàm không làm được.

### A. Kỹ thuật JOIN FETCH (Tránh lỗi N+1 Queries)

Bình thường khi lấy Product, JPA sẽ không lấy Category (Lazy Loading). Khi bạn gọi `product.getCategory().getName()` sẽ sinh ra thêm 1 câu query nữa. Nếu có 100 sản phẩm -> 101 câu query (Lỗi N+1).

**Giải quyết:**

```java
@Query("SELECT p FROM Product p " +
       "LEFT JOIN FETCH p.category " + // Lấy luôn thông tin Category trong 1 lần query
       "WHERE p.active = true " +
       "ORDER BY p.createdAt DESC")
List<Product> findAllActiveWithCategory();
```

### B. Kỹ thuật Dynamic Search (Tìm kiếm động)

Tìm kiếm với nhiều tiêu chí kết hợp: Tên, Giá từ...đến, Danh mục. Người dùng có thể nhập hoặc không nhập bất kỳ tiêu chí nào.

**Code ví dụ (Trích đoạn `advancedSearchOrderByPriceAsc`):**

```java
@Query("SELECT p FROM Product p " +
       "LEFT JOIN FETCH p.category c " +
       "WHERE p.active = true " +
       // 1. Tìm theo Tên (Nếu keyword null thì bỏ qua, nếu có thì tìm gần đúng LIKE)
       "AND (:keyword IS NULL OR LOWER(p.name) LIKE LOWER(CONCAT('%', :keyword, '%'))) " +
       // 2. Tìm theo Giá ( >= priceFrom)
       "AND (:priceFrom IS NULL OR p.price >= :priceFrom) " +
       // 3. Tìm theo Giá ( <= priceTo)
       "AND (:priceTo IS NULL OR p.price <= :priceTo) " +
       // 4. Tìm theo Danh mục
       "AND (:categoryId IS NULL OR c.id = :categoryId) " +
       "ORDER BY p.price ASC")
List<Product> advancedSearchOrderByPriceAsc(
        @Param("keyword") String keyword,
        @Param("priceFrom") BigDecimal priceFrom,
        ...);
```

✅ **Giải thích**: Cấu trúc `(:param IS NULL OR condition)` là "Signature move" để làm Dynamic Query trong SQL/JPQL.

### C. Kỹ thuật Aggregation (Thống kê - Gom nhóm)

Tính toán sản phẩm bán chạy nhất dựa trên lịch sử đơn hàng. Cần dùng hàm `SUM`, `GROUP BY`.

**Code ví dụ (`findBestSellingProductIds`):**

```java
@Query("SELECT oi.product.id FROM OrderItem oi " + // Chọn ID sản phẩm từ bảng chi tiết đơn hàng
       "JOIN oi.order o " + // Join sang bảng Order
       "WHERE o.status IN (COMPLETED, DELIVERED) " + // Chỉ tính đơn thành công
       "GROUP BY oi.product.id " + // Gom nhóm theo từng sản phẩm
       "ORDER BY SUM(oi.quantity) DESC") // Sắp xếp theo Tổng số lượng bán giảm dần
List<Long> findBestSellingProductIds();
```

---

**Tổng kết để nói với giáo viên:**
"Em sử dụng **Spring Data JPA** tối đa. Với các nghiệp vụ đơn giản như `findBySlug`, em dùng **Derived Query** cho code gọn. Với báo cáo và tìm kiếm nhiều điều kiện, em dùng **JPQL** với `@Query` để tối ưu hiệu năng (dùng `JOIN FETCH`) và xử lý logic phức tạp (`GROUP BY`, `Dynamic WHERE`)."
