# GIẢI THÍCH CHI TIẾT VỀ SECURITY (BẢO MẬT) - 1 ĐIỂM

**Tài liệu hỗ trợ thuyết trình phần Bảo mật ứng dụng**

Dự án áp dụng mô hình bảo mật **Stateless Authentication** hiện đại sử dụng **Spring Security 6** kết hợp với **JWT (JSON Web Token)**.

**3 Thành phần quan trọng nhất cần nắm:**

---

## 1. Cơ chế hoạt động (Flow)

Khi một request gửi đến Server, nó sẽ đi qua các lớp bảo vệ như sau:

1.  **Client (Frontend)**: Gửi request kèm Token ở Header.
    - Ví dụ: `Authorization: Bearer eyJhbGciOiJIUzI1NiJ9...`
2.  **JwtAuthenticationFilter**: Đứng canh ở cửa ngõ.
    - Nhiệm vụ: Chặn request lại, lấy token ra kiểm tra.
    - Nếu Token hợp lệ -> Lấy thông tin User -> Cho đi qua.
    - Nếu Token sai/hết hạn -> Chặn lại (401 Unauthorized).
3.  **SecurityConfig (Authorize)**: Kiểm tra quyền hạn.
    - Nhiệm vụ: Xem User này có được vào trang này không? (Ví dụ: User thường mà đòi vào trang Admin là chặn ngay - 403 Forbidden).
4.  **Controller**: Nếu qua được hết các bước trên thì mới được vào xử lý logic.

---

## 2. Giải thích Code Chi Tiết

### A. Cấu hình Bảo mật (`SecurityConfig.java`)

Đây là "bộ não" quản lý bảo mật của cả ứng dụng.

**Code quan trọng:**

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf.disable()) // Tắt CSRF vì dùng JWT (không dùng Session)
        .sessionManagement(sess -> sess.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // Không lưu session phía Server

        .authorizeHttpRequests(auth -> auth
            // 1. Cho phép ai cũng vào được (Public)
            .requestMatchers("/api/auth/**").permitAll() // Đăng nhập/Đăng ký
            .requestMatchers(HttpMethod.GET, "/api/products/**").permitAll() // Xem sản phẩm

            // 2. Chỉ Admin mới được vào
            .requestMatchers("/api/admin/**").hasRole("ADMIN")

            // 3. Các trang còn lại bắt buộc phải đăng nhập
            .anyRequest().authenticated()
        )
        // Thêm màng lọc JWT vào trước màng lọc đăng nhập mặc định
        .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

    return http.build();
}
```

### B. Màng lọc xác thực (`JwtAuthenticationFilter.java`)

Nơi kiểm tra "vé vào cửa" (Token) của từng request.

**Code quan trọng:**

```java
@Override
protected void doFilterInternal(...) {
    // 1. Lấy chuỗi JWT từ Header request
    String jwt = parseJwt(request);

    // 2. Nếu có JWT và Token hợp lệ (chữ ký đúng, chưa hết hạn)
    if (jwt != null && jwtUtils.validateJwtToken(jwt)) {

        // 3. Lấy tên User từ Token (username)
        String username = jwtUtils.getUsernameFromJwtToken(jwt);

        // 4. Set thông tin User vào Context của Spring Security
        // (Để các bước sau biết đây là ai đang truy cập)
        SecurityContextHolder.getContext().setAuthentication(authentication);
    }

    // 5. Cho đi tiếp
    filterChain.doFilter(request, response);
}
```

### C. Công cụ xử lý Token (`JwtUtils.java`)

Nơi "ký tên" tạo ra Token và "soi" Token.

- `generateJwtToken()`: Tạo Token mới khi đăng nhập thành công. Token chứa Username, thời hạn (Expiration).
- `validateJwtToken()`: Kiểm tra Token gửi lên có phải do Server ký không? Có bị sửa đổi không? Có hết hạn chưa?

---

## 3. Câu trả lời mẫu với Giáo viên

**Giáo viên:** _"Tại sao em dùng JWT mà không dùng Session truyền thống?"_

**Trả lời:**
"Dạ thưa thầy, em chọn JWT vì 2 lý do chính:

1.  **Chia tách Frontend - Backend**: Project của em Frontend viết bằng React/Next.js chạy độc lập, nên dùng Token (Stateless) sẽ tiện hơn là quản lý Session (Stateful).
2.  **Hiệu năng**: Server không cần tốn RAM để nhớ session của hàng nghìn user. Mỗi request tự mang thông tin xác thực của mình đi theo."

**Giáo viên:** _"Password lưu trong database có mã hóa không?"_

**Trả lời:**
"Dạ có ạ, em dùng `BCryptPasswordEncoder` trong `SecurityConfig` để băm (hash) mật khẩu trước khi lưu. Ngay cả Admin mở database ra cũng không đọc được pass của user ạ."
