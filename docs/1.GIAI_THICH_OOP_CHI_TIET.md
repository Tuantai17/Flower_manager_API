# GIẢI THÍCH CHI TIẾT VỀ OOP (LẬP TRÌNH HƯỚNG ĐỐI TƯỢNG) - 2 ĐIỂM

**Sử dụng tài liệu này để thuyết trình phần OOP với giáo viên.**

Dự án này áp dụng đầy đủ 4 tính chất cơ bản của OOP: **Đóng gói**, **Kế thừa**, **Đa hình** và **Trừu tượng**. Dưới đây là bằng chứng cụ thể trong code.

---

## 1. Tính Đóng gói (Encapsulation)

**Định nghĩa:** Che giấu dữ liệu và chi tiết cài đặt bên trong class, chỉ cho phép truy cập thông qua các phương thức công khai (getter/setter).

**Minh chứng trong dự án:**
File: `src/main/java/com/flower/manager/entity/Product.java`

- Các thuộc tính của sản phẩm (`id`, `name`, `price`...) đều được khai báo là `private`.
- Sử dụng annotation `@Getter`, `@Setter` của Lombok để sinh ra các phương thức truy cập.
- Có logic set giá trị mặc định (`@Builder.Default`) hoặc xử lý trước khi lưu (`@PrePersist`).

**Code ví dụ:**

```java
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id; // Private field - Không thể truy cập trực tiếp từ bên ngoài

    @Column(nullable = false, length = 200)
    private String name; // Private field

    @Column(nullable = false, precision = 15, scale = 2)
    private BigDecimal price;

    // Lombok tự động sinh ra public Long getId(), public void setName(String name)...

    @PrePersist // Logic nội tại được ẩn giấu
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }
}
```

---

## 2. Tính Kế thừa (Inheritance)

**Định nghĩa:** Class con kế thừa các thuộc tính và phương thức từ class cha (hoặc interface), giúp tái sử dụng mã nguồn.

**Minh chứng trong dự án:**
File: `src/main/java/com/flower/manager/exception/ResourceNotFoundException.java`

- Class `ResourceNotFoundException` kế thừa từ `RuntimeException`.
- Nó tận dụng được các constructor và cơ chế throw exception của Java Exception.

**Code ví dụ:**

```java
@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException { // Kế thừa RuntimeException

    public ResourceNotFoundException(String message) {
        super(message); // Gọi constructor của lớp cha
    }
}
```

File: `src/main/java/com/flower/manager/entity/User.java`

- Class `User` kế thừa (thực thi) interface `UserDetails` của Spring Security để hưởng tính năng xác thực.

---

## 3. Tính Đa hình (Polymorphism)

**Định nghĩa:** Một đối tượng có thể được coi là nhiều kiểu khác nhau (kiểu cha, kiểu interface). Cùng một phương thức nhưng có thể có nhiều cách thực hiện khác nhau (Override).

**Minh chứng trong dự án:**
File: `src/main/java/com/flower/manager/service/product/ProductServiceImpl.java`

- Class `ProductServiceImpl` implement interface `ProductService`.
- Controller khai báo biến kiểu `ProductService` nhưng Spring sẽ tiêm vào instance của `ProductServiceImpl`.
- Phương thức `create` trong `ProductServiceImpl` ghi đè (`@Override`) định nghĩa trừu tượng trong interface.

**Code ví dụ:**

```java
// Trong Service Implementation
@Service
public class ProductServiceImpl implements ProductService { // implements tạo tính đa hình

    @Override // Ghi đè phương thức của interface
    public ProductDTO create(ProductCreateDTO dto) {
        // Logic tạo sản phẩm cụ thể
        Product product = productMapper.toEntity(dto);
        Product saved = productRepository.save(product);
        return productMapper.toDTO(saved);
    }
}

// Trong Controller (Sử dụng tính đa hình)
public class ProductController {
    private final ProductService productService; // Chỉ quan tâm là ProductService, không cần biết là Impl nào

    // Spring tự động tiêm ProductServiceImpl vào đây
}
```

---

## 4. Tính Trừu tượng (Abstraction)

**Định nghĩa:** Tập trung vào cái đối tượng "làm được gì" (interface) hơn là "làm như thế nào" (implementation). Che giấu sự phức tạp của logic nghiệp vụ.

**Minh chứng trong dự án:**
File: `src/main/java/com/flower/manager/service/product/ProductService.java`

- Đây là một **Interface**. Nó chỉ định nghĩa danh sách các chức năng mà service sản phẩm phải có (`create`, `update`, `delete`...) nhưng hoàn toàn không chứa code xử lý.
- Giúp tách biệt giữa định nghĩa API và logic thực thi.

**Code ví dụ:**

```java
public interface ProductService {

    // Phương thức trừu tượng - Chỉ định nghĩa Input/Output
    ProductDTO create(ProductCreateDTO dto);

    ProductDTO update(Long id, ProductUpdateDTO dto);

    void delete(Long id);

    ProductDTO getById(Long id);

    List<ProductDTO> searchByName(String keyword);
}
```

_Người dùng `ProductService` (như Controller) không cần biết logic `searchByName` query database như thế nào, chỉ cần biết gọi hàm là có dữ liệu._
